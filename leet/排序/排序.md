#### 八大排序算法
![八大排序算法](https://mmbiz.qpic.cn/mmbiz_png/MQ4FoG1HmnIounJsWSXZfDLJt1kG3t5V5iacJHPiaa6gvfcG5GDbOQefIrpGxKyr6DrxakdY5La68OOTDUsHt8XQ/640?wx_fmt=png "测试title")

##### 冒泡排序 
双循环，O(n^2)

算法步骤
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


![冒泡排序gif](https://mmbiz.qpic.cn/mmbiz_gif/MQ4FoG1HmnIounJsWSXZfDLJt1kG3t5VL4nZJtTUPSe7voA0tTiaHt9ZDshJic0SM9bapHg31OHOGjQiclbQjl1QA/640?wx_fmt=gif)
```python
def bubble_sort(arr):
    for i in range(1, len(arr)):
        for j in range(0, len(arr) - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

##### 选择排序
![选择排序gif](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014185807987-1057233489.gif)
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。
所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
```python
def select_sort(arr):
    for i in range(len(arr) - 1):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        if min_idx != i:
            arr[min_idx], arr[i] = arr[i], arr[min_idx]
    return arr
```

##### 插入排序
![插入排序gif](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190107085-1652380825.gif)
插入排序是一种简单直观的排序算法，因为只要打过扑克牌的人都应该能够秒懂。
它的工作原理是通过构建有序序列，从第一个元素开始，该元素可以认为已经被排序，
对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
```python
def insertion_sort(arr):
    """O(n^2)"""
    for i in range(1, len(arr)):
        cur = arr[i]
        pre_idx = i - 1
        while pre_idx >= 0 and arr[pre_idx] > cur:
            arr[pre_idx + 1] = arr[pre_idx]
            pre_idx -= 1
        arr[pre_idx + 1] = cur
    return arr
```

##### 希尔排序
![希尔排序](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190225518-1370369504.gif)
希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”，
是直接插入排序算法的一种更高效的改进版本，它与插入排序的不同之处在于，它会优先比较距离较远的元素。

希尔排序，也称递减增量排序算法（Diminishing Increment Sort），是插入排序的一种更高效的改进版本。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：
   * 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
   * 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，
待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。


记忆方法：插入排序是每轮都是一小步，希尔排序是先大步后小步，它第一个突破O(n^2)的排序算法。
联想起阿姆斯特朗登月之后说：这是我个人一小步，却是人类迈出的一大步。
 ```python
def shell_sort(arr):
    """希尔排序，O(n^(3/2)), 最坏O(n^2)"""
    n = len(arr)
    gap = n // 2  # 初始步长
    while gap > 0:
        for i in range(gap, n):  # 每个步长进行插入排序
            tmp = arr[i]
            j = i - gap  # pre_idx
            while j >= 0 and arr[j] > tmp:
                arr[j + gap] = arr[j]
                j -= gap
            arr[j + gap] = tmp
        gap = gap // 2  # 得到新的步长
    return arr
```
使用Sedgewick增量序列的希尔排序
已知的最快的增量式是由 Sedgewick 提出的 (1, 5, 19, 41, 109,…)，
该步长的项来自`9*4^i-9*2^i+1 或 4^(i+2)-3*2^(i+2)+1`这两个算式。
这项研究也表明 “比较在希尔排序中是最主要的操作，而不是交换。用这样增量式的希尔排序比插入排序和堆排序都要快，
甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。
```python
def getSedgewickStepArr(n):
    """Sedgewick增量序列 最坏时间复杂度为𝑂(𝑁^(4/3))；平均时间复杂度约为𝑂(𝑁^(7/6))
    D=9*4^i-9*2^i+1 或 4^(i+2)-3*2^(i+2)+1 , i>=0
    稍微变一下形：D=9*(2^(2i)-2^i)+1 或 2^(2i+4)-3*2^(i+2)+1 , i>=0
    """
    i = 0
    arr = []
    while True:
        tmp = 9 * ((1 << 2 * i) - (1 << i)) + 1
        if tmp <= n:
            arr.append(tmp)
        tmp = (1 << 2 * i + 4) - 3 * (1 << i + 2) + 1
        if tmp <= n:
            arr.append(tmp)
        else:
            break
        i += 1
    return arr


def shellSort(arr):
    n = len(arr)
    # 获取Sedgewick增量序列
    stepArr = getSedgewickStepArr(n)
    for step in reversed(stepArr):
        for i in range(step, n):
            j = i
            tmp = arr[j]
            while j >= step:
                if tmp < arr[j - step]:
                    arr[j] = arr[j - step]
                    j -= step
                else:
                    break
            arr[j] = tmp
```
##### 归并排序
![归并排序.gif](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190406955-1250220054.gif)
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
   * 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
   * 自下而上的迭代；

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。
```python
def merge(left, right):
    l, r = 0, 0
    res = []
    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            res.append(left[l])
            l += 1
        else:
            res.append(right[r])
            r += 1
    res.extend(left[l:])
    res.extend(right[r:])
    return res


def merge_sort(arr):
    """归并排序O(nlog(n))"""
    if len(arr) < 2:
        return arr
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    return merge(merge_sort(left), merge_sort(right))
```

归排的应用：[逆序对问题-求逆序数](https://www.cnblogs.com/kimsimple/p/6727529.html)
leetcode: [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)

##### 快速排序
![快速排序.gif](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190611263-753990372.gif)
从数列中挑出一个元素，称为“基准”（pivot），
重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。
递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
```python
def partition2(arr, left, right):
    """设置arr[right]为基准数，代码会稍微优雅一点，没有那么多+1"""
    base = arr[right]
    i = left
    for j in range(left, right):
        # 两个指针，j一直向前，当遍历到比基数大的数时，i,j错位，i停下记下大数的位置，当遇到比j小数时，交换位置；i可以继续向前
        if arr[j] <= base:  # < 或<=都行
            arr[j], arr[i] = arr[i], arr[j]
            i += 1
    # 遍历结束后i的位置比基数大，交换
    arr[i], arr[right] = arr[right], arr[i]
    return i


def partition(arr, left, right):
    """设置arr[left]为基准数，小于基准的就从往左边放"""
    base = arr[left]
    i = left
    for j in range(left + 1, right + 1):
        # 记i为平分点，当遍历到比base大的数后，索引j继续走，比base小时，（将其和i后面一位交换，i前进一位）
        if arr[j] < base:  # < 或<=都行
            i += 1
            arr[j], arr[i] = arr[i], arr[j]
    # 遍历结束后i的位置比基数大，交换
    arr[i], arr[left] = arr[left], arr[i]
    return i


def quick_sort(arr, left, right):
    """算法导论和leetcode题解中的快排"""
    if left < right:
        p = partition2(arr, left, right)
        quick_sort(arr, left, p - 1)
        quick_sort(arr, p + 1, right)
    return arr


def quick_sort1(arr, left, right):
    """常见的双指针双向奔赴快排"""
    if left >= right:
        return
    low = left
    high = right
    base = arr[low]
    while left < right:
        # 和下面的顺序不能变，从右数将第一个小于基数的赋给
        while arr[right] > base and left < right:
            right -= 1
        arr[left] = arr[right]
        while arr[left] <= base and left < right:
            left += 1
        arr[right] = arr[left]
    arr[left] = base
    quick_sort1(arr, low, left - 1)
    quick_sort1(arr, left + 1, high)
    return arr


def quick_sort2(arr):
    """超级精简版快速排序，空间占用大"""
    if len(arr) <= 1: return arr
    return quick_sort2([lt for lt in arr[1:] if lt < arr[0]]) + arr[0:1] \
           + quick_sort2([ge for ge in arr[1:] if ge >= arr[0]])
```

##### 堆排序
![堆排序.gif](https://img2018.cnblogs.com/blog/1356841/201810/1356841-20181014190700059-194955464.gif)
若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, `A[parent(i)] ≥ A[i]`。

重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。
```python
def sift_down(arr, start, end):
    """从根节点开始，比较其与两个子节点的大小：当当前节点小于其子节点时，则将当前节点与较大的一个子节点交换位置，
    然后继续往下比较，直到当前节点是叶子节点或者当前节点大于子节点"""
    root, child = start, 2 * start + 1  # 初始化根节点和最大子节点，暂时将左子节点视为最大子节点
    while child <= end:
        # 左子节点和右子节点比较，更新最大子节点
        if child + 1 <= end and arr[child] < arr[child + 1]:
            child += 1
        # 根节点小于最大子节点，交换节点值，并将root指针移动到子节点上，将child指针移动到新root的子节点上
        if arr[root] < arr[child]:
            arr[root], arr[child] = arr[child], arr[root]
            root, child = child, 2 * root + 1  # 更新根节点和子节点
        else:
            break
    return arr


def heap_sort(arr):
    """堆排序，重复从大顶堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，
    并让残余的堆维持最大堆积性质。"""
    # 创建大顶堆 # len(arr) - 2) // 2，因为: last_node = len(arr)-1, parent=(last_node-1)//2
    for start in range((len(arr) - 2) // 2, -1, -1):
        sift_down(arr, start, len(arr) - 1)

    # 堆排序
    for end in range(len(arr) - 1, 0, -1):
        arr[0], arr[end] = arr[end], arr[0]
        sift_down(arr, 0, end - 1)
    return arr


def heapify(tree, n, i):
    if i >= n:
        return
    c1 = 2 * i + 1
    c2 = 2 * i + 2
    max_node = i
    if c1 < n and tree[c1] > tree[max_node]:
        max_node = c1
    if c2 < n and tree[c2] > tree[max_node]:
        max_node = c2
    if max_node != i:
        tree[max_node], tree[i] = tree[i], tree[max_node]
        heapify(tree, n, max_node)


def heap_sort2(arr):
    """递归的方式实现堆排序"""
    # len(arr) - 2) // 2，因为: last_node = len(arr)-1, parent=(last_node-1)//2
    for start in range((len(arr) - 2) // 2, -1, -1):
        heapify(arr, len(arr), start)
    for end in range((len(arr) - 1), 0, -1):
        arr[0], arr[end] = arr[end], arr[0]
        heapify(arr, end, 0)
    return arr
```

##### 计数排序
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
```python
def counting_sort(arr, max_value):
    """计数排序"""
    # 初始化桶，对于arr中的数字i，bucket[i]等于数字i在arr中的出现次数
    bucket_len = max_value + 1
    bucket = [0] * bucket_len
    for i in arr:
        bucket[i] += 1
    # 填值回arr
    idx = 0
    for j in range(bucket_len):
        for _ in range(bucket[j]):
            arr[idx] = j
            idx += 1
    return arr
```
##### 桶排序
桶排序是将待排序集合中处于同一个值域的元素存入同一个桶中，也就是根据元素值特性将集合拆分为多个区域，则拆分后形成的多个桶，从值域上看是处于有序状态的。对每个桶中元素进行排序，则所有桶中元素构成的集合是已排序的。
```python
def bucketSort(arr):
    """这里选取的映射的规则是f(x) = x//10 -min//10 即以间隔大小 10 来区分不同值域
    桶内排序算法为堆排序
    """
    maximum, minimum = max(arr), min(arr)
    bucketArr = [[] for i in range(maximum // 10 - minimum // 10 + 1)]  # set the map rule and apply for space
    for i in arr:  # map every element in array to the corresponding bucket
        index = i // 10 - minimum // 10
        bucketArr[index].append(i)
    arr.clear()
    for i in bucketArr:
        heapSort(i)   # sort the elements in every bucket
        arr.extend(i)  # move the sorted elements in bucket to array
```

#### 参考文章
2. [python 十大经典排序算法](https://www.cnblogs.com/wuxinyan/p/8615127.html)
1. [Python实现十大常用排序算法 ](https://www.sohu.com/a/304883839_571478)
2. [python——常见排序算法解析](https://www.cnblogs.com/huang-yc/p/9774287.html)
